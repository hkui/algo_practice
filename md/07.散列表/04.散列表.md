#### 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。    
我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。        
当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据

### 散列函数
散列函数，顾名思义，它是一个函数。我们可以把它定义成hash(key)，其中key表示元素的键值，hash(key)的值表示经过散列函数计算得到的散列值
#### 散列函数设计的基本要求
* 散列函数计算得到的散列值是一个非负整数；
* 如果key1 = key2，那hash(key1) == hash(key2)；
* 如果key1 ≠ key2，那hash(key1) ≠ hash(key2)。
> 第三点理解起来可能会有问题,这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的。        
即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。                     
所以我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决

### 散列冲突
再好的散列函数也无法避免散列冲突。常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）

#### 1.开放寻址法
开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入       
那如何重新探测新的位置呢？
* 1.线性探测（Linear Probing）          
当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

以一道面试题为例                    
已知一个线性表(38，25，74，63，52，48)，采用的散列函数为H(Key)=Key%7，将元素散列到表长为7的哈希表中存储。
若采用线性探测的开放定址法解决冲突，则在该散列表上进行等概率成功查找的平均查找长度为 2

38,25,74,63,52,48 mod 7后分别为 3,4,4,0,3,6
![](https://note.youdao.com/yws/api/personal/file/7F76999FA1DA452F922542E09D0B117A?method=download&shareKey=87e570e4329acb28aee38b09e03d07bd)

在散列表中查找元素的过程有点儿类似插入过程。    
我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。
如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中

```
查找 38,25,74,63,52,48
查找38 mod为3 在3的位置找到 需要1次
查找25 mod为4 在4的位置找到 需要1次
查找74 mod为4 在4的位置存储的为25 不等于74，继续查找到5，发现这个位置存储的为74 等于要找的位置，共查找了2次
查找63 mod为0 在0位置找到63 查找次数为1
查找52 mod为3 在3的位置发现存储的为38，不等，继续查找位置4发现未25，不等，继续在位置5查找 发现74 不等，所以继续查找位置6，发现未52 等，查找次数为4
查找48 mod为6 在6处发现不等于48，继续查找0处，发现不等，继续查找1出发现等，查找次数为3

所以平均查找长度为(1+1+2+1+4+3)/6=2

如果查找8 mod为1 在1出发现48 不等，继续查找位置2处，发现为空，遍历到空闲位置还没找到说明8不在散列表中
```
散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？

在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。        
但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？

#### 删除元素
我们可以将删除的元素，特殊标记为deleted。当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来，而是继续往下探测

线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。 
极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。

对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，二次探测（Quadratic probing）和双重散列（Double hashing）。

##### 二次探测        
跟线性探测很像，线性探测每次探测的步长是1，那它探测的下标序列就是hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是hash(key)+0，hash(key)+12，hash(key)+22……

##### 双重散列
意思就是不仅要使用一个散列函数。我们使用一组散列函数hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。

不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。

> 散列表的装载因子=填入表中的元素个数/散列表的长度

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降
### 2.链表法
链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。  
我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中
![](https://note.youdao.com/yws/api/personal/file/9ED5C61FBC034CF0A70475EC5DFDA2F8?method=download&shareKey=948a8b10cb6c960e4ba001eaa06b48ef)

当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是O(1)。        
当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？

实际上，这两个操作的时间复杂度跟链表的长度k成正比，也就是O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中n表示散列中数据的个数，m表示散列表中“槽”的个数




![](https://note.youdao.com/yws/api/personal/file/42659ECDEAF148D1B8DAB2F1F78A2533?method=download&shareKey=62e4f6bdc6429c017d29af3a1763f9de)

##### 对之前的面试题，如果采用拉链法
        
```
查找 38  1次
查找 25  1次
查找 74  2次
查找 63  1次
查找 52 2次
查找 48 1次

所以平均查找长度为 (1+1+2+1+2+1)/6=1.3333
```

散列表的查询效率并不能笼统地说成是O(1)。
它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。

在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从O(1)急剧退化为O(n)。

如果散列表中有10万个数据，退化后的散列表查询的效率就下降了10万倍。更直接点说，如果之前运行100次查询只需要0.1秒，那现在就需要1万秒。这样就有可能因为查询操作消耗大量CPU或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。









